var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { basicFetcher } from '../utils/Fetcher/basicFetcher';
// TODO: remove it and provide utils to implement translators
/**
 * Basic abstract class for translator
 */
var BaseTranslator = /** @class */ (function () {
    function BaseTranslator(options) {
        var _this = this;
        this.options = {};
        /**
         * Util to wrap url to CORS proxy
         */
        this.wrapUrlToCorsProxy = function (url) {
            // Use as prefix
            if (typeof _this.options.corsProxy === 'string') {
                return _this.options.corsProxy + url;
            }
            // Run user defined transformation
            if (typeof _this.options.corsProxy === 'function') {
                return _this.options.corsProxy(url);
            }
            return url;
        };
        this.fetch = function (url, options) { return __awaiter(_this, void 0, void 0, function () {
            var fetcher;
            var _a;
            return __generator(this, function (_b) {
                fetcher = (_a = this.options.fetcher) !== null && _a !== void 0 ? _a : basicFetcher;
                return [2 /*return*/, fetcher(url, options)];
            });
        }); };
        if (options !== undefined) {
            this.options = options;
        }
    }
    BaseTranslator.prototype.checkLimitExceeding = function (text) {
        var plainText = Array.isArray(text) ? text.join('') : text;
        var extra = plainText.length - this.getLengthLimit();
        return extra > 0 ? extra : 0;
    };
    BaseTranslator.translatorName = 'UnknownTranslator';
    BaseTranslator.isRequiredKey = function () { return false; };
    BaseTranslator.isSupportedAutoFrom = function () { return false; };
    BaseTranslator.getSupportedLanguages = function () { return []; };
    return BaseTranslator;
}());
export { BaseTranslator };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyYW5zbGF0b3JzL0Jhc2VUcmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQWtDN0QsNkRBQTZEO0FBQzdEOztHQUVHO0FBRUg7SUFnQkMsd0JBQVksT0FBOEI7UUFBMUMsaUJBSUM7UUFMa0IsWUFBTyxHQUFHLEVBQTBCLENBQUM7UUF5QnhEOztXQUVHO1FBQ08sdUJBQWtCLEdBQUcsVUFBQyxHQUFXO1lBQzFDLGdCQUFnQjtZQUNoQixJQUFJLE9BQU8sS0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssUUFBUSxFQUFFO2dCQUMvQyxPQUFPLEtBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQzthQUNwQztZQUVELGtDQUFrQztZQUNsQyxJQUFJLE9BQU8sS0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssVUFBVSxFQUFFO2dCQUNqRCxPQUFPLEtBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ25DO1lBRUQsT0FBTyxHQUFHLENBQUM7UUFDWixDQUFDLENBQUM7UUFFUSxVQUFLLEdBQVksVUFDMUIsR0FBVyxFQUNYLE9BQTBCOzs7O2dCQUVwQixPQUFPLEdBQUcsTUFBQSxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sbUNBQUksWUFBWSxDQUFDO2dCQUNyRCxzQkFBTyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxFQUFDOzthQUM3QixDQUFDO1FBOUNELElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUMxQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztTQUN2QjtJQUNGLENBQUM7SUFjTSw0Q0FBbUIsR0FBMUIsVUFBMkIsSUFBdUI7UUFDakQsSUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzdELElBQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3ZELE9BQU8sS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQW5Dc0IsNkJBQWMsR0FBVyxtQkFBbUIsQ0FBQztJQUV0RCw0QkFBYSxHQUFHLGNBQU0sT0FBQSxLQUFLLEVBQUwsQ0FBSyxDQUFDO0lBRTVCLGtDQUFtQixHQUFHLGNBQU0sT0FBQSxLQUFLLEVBQUwsQ0FBSyxDQUFDO0lBRWxDLG9DQUFxQixHQUFHLGNBQWtCLE9BQUEsRUFBRSxFQUFGLENBQUUsQ0FBQztJQXVENUQscUJBQUM7Q0FoRUQsQUFnRUMsSUFBQTtTQWhFcUIsY0FBYyIsImZpbGUiOiJ0cmFuc2xhdG9ycy9CYXNlVHJhbnNsYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZldGNoZXIsIEZldGNoZXJPcHRpb25zLCBGZXRjaGVyUmVxdWVzdFR5cGUgfSBmcm9tICcuLi91dGlscy9GZXRjaGVyJztcbmltcG9ydCB7IGJhc2ljRmV0Y2hlciB9IGZyb20gJy4uL3V0aWxzL0ZldGNoZXIvYmFzaWNGZXRjaGVyJztcbmltcG9ydCB7IFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnMsIGxhbmdDb2RlLCBsYW5nQ29kZVdpdGhBdXRvIH0gZnJvbSAnLi9UcmFuc2xhdG9yJztcblxuZXhwb3J0IHR5cGUgVHJhbnNsYXRvck9wdGlvbnM8TyBleHRlbmRzIFJlY29yZDxhbnksIGFueT4gPSB7fT4gPSBPICYge1xuXHQvKipcblx0ICogQVBJIGVuZHBvaW50IFVSTFxuXHQgKi9cblx0YXBpSG9zdD86IHN0cmluZztcblxuXHQvKipcblx0ICogQWNjZXNzIGtleSBmb3IgcmVxdWVzdHMgdG8gdHJhbnNsYXRvciBBUElcblx0ICovXG5cdGFwaUtleT86IHN0cmluZztcblxuXHQvKipcblx0ICogVW5pb24gdGV4dCBhcnJheSB0byAxIHJlcXVlc3QgKG9yIG1vcmUsIGJ1dCBsZXNzIHRoYW4gdXN1YWx5IGFueXdheSkuXG5cdCAqXG5cdCAqIE9wdGlvbiBmb3IgcmVkdWNlIHRoZSBudW1iZXIgb2YgcmVxdWVzdHMsIGJ1dCBpdCBjYW4gbWFrZSBhcnRlZmFjdHMgaW4gdHJhbnNsYXRlZCB0ZXh0LlxuXHQgKlxuXHQgKiBTb21lIG1vZHVsZXMgbWF5IG5vdCBzdXBwb3J0IHRoaXMgZmVhdHVyZS5cblx0ICovXG5cdHVzZU11bHRpcGxleGluZz86IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEFkZGl0aW9uYWwgaGVhZGVycyBmb3IgcmVxdWVzdHNcblx0ICovXG5cdGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG5cdC8qKlxuXHQgKiBDdXN0b20gZmV0Y2hlclxuXHQgKi9cblx0ZmV0Y2hlcj86IEZldGNoZXI7XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgaXQgYW5kIHByb3ZpZGUgdXRpbHMgdG8gaW1wbGVtZW50IHRyYW5zbGF0b3JzXG4vKipcbiAqIEJhc2ljIGFic3RyYWN0IGNsYXNzIGZvciB0cmFuc2xhdG9yXG4gKi9cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VUcmFuc2xhdG9yPEMgZXh0ZW5kcyBSZWNvcmQ8YW55LCBhbnk+ID0ge30+XG5pbXBsZW1lbnRzIFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnNcbntcblx0cHVibGljIHN0YXRpYyByZWFkb25seSB0cmFuc2xhdG9yTmFtZTogc3RyaW5nID0gJ1Vua25vd25UcmFuc2xhdG9yJztcblxuXHRwdWJsaWMgc3RhdGljIGlzUmVxdWlyZWRLZXkgPSAoKSA9PiBmYWxzZTtcblxuXHRwdWJsaWMgc3RhdGljIGlzU3VwcG9ydGVkQXV0b0Zyb20gPSAoKSA9PiBmYWxzZTtcblxuXHRwdWJsaWMgc3RhdGljIGdldFN1cHBvcnRlZExhbmd1YWdlcyA9ICgpOiBsYW5nQ29kZVtdID0+IFtdO1xuXG5cdHB1YmxpYyBhYnN0cmFjdCBnZXRMZW5ndGhMaW1pdCgpOiBudW1iZXI7XG5cblx0cHVibGljIGFic3RyYWN0IGdldFJlcXVlc3RzVGltZW91dCgpOiBudW1iZXI7XG5cblx0cHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnMgPSB7fSBhcyBUcmFuc2xhdG9yT3B0aW9uczxDPjtcblx0Y29uc3RydWN0b3Iob3B0aW9ucz86IFRyYW5zbGF0b3JPcHRpb25zPEM+KSB7XG5cdFx0aWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR9XG5cdH1cblxuXHRhYnN0cmFjdCB0cmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGxhbmdGcm9tOiBsYW5nQ29kZVdpdGhBdXRvLFxuXHRcdGxhbmdUbzogbGFuZ0NvZGUsXG5cdCk6IFByb21pc2U8c3RyaW5nPjtcblxuXHRhYnN0cmFjdCB0cmFuc2xhdGVCYXRjaChcblx0XHR0ZXh0OiBzdHJpbmdbXSxcblx0XHRsYW5nRnJvbTogbGFuZ0NvZGVXaXRoQXV0byxcblx0XHRsYW5nVG86IGxhbmdDb2RlLFxuXHQpOiBQcm9taXNlPEFycmF5PHN0cmluZyB8IG51bGw+PjtcblxuXHRwdWJsaWMgY2hlY2tMaW1pdEV4Y2VlZGluZyh0ZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuXHRcdGNvbnN0IHBsYWluVGV4dCA9IEFycmF5LmlzQXJyYXkodGV4dCkgPyB0ZXh0LmpvaW4oJycpIDogdGV4dDtcblx0XHRjb25zdCBleHRyYSA9IHBsYWluVGV4dC5sZW5ndGggLSB0aGlzLmdldExlbmd0aExpbWl0KCk7XG5cdFx0cmV0dXJuIGV4dHJhID4gMCA/IGV4dHJhIDogMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVdGlsIHRvIHdyYXAgdXJsIHRvIENPUlMgcHJveHlcblx0ICovXG5cdHByb3RlY3RlZCB3cmFwVXJsVG9Db3JzUHJveHkgPSAodXJsOiBzdHJpbmcpID0+IHtcblx0XHQvLyBVc2UgYXMgcHJlZml4XG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29yc1Byb3h5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jb3JzUHJveHkgKyB1cmw7XG5cdFx0fVxuXG5cdFx0Ly8gUnVuIHVzZXIgZGVmaW5lZCB0cmFuc2Zvcm1hdGlvblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvcnNQcm94eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jb3JzUHJveHkodXJsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJsO1xuXHR9O1xuXG5cdHByb3RlY3RlZCBmZXRjaDogRmV0Y2hlciA9IGFzeW5jIDxUIGV4dGVuZHMgRmV0Y2hlclJlcXVlc3RUeXBlPihcblx0XHR1cmw6IHN0cmluZyxcblx0XHRvcHRpb25zOiBGZXRjaGVyT3B0aW9uczxUPixcblx0KSA9PiB7XG5cdFx0Y29uc3QgZmV0Y2hlciA9IHRoaXMub3B0aW9ucy5mZXRjaGVyID8/IGJhc2ljRmV0Y2hlcjtcblx0XHRyZXR1cm4gZmV0Y2hlcih1cmwsIG9wdGlvbnMpO1xuXHR9O1xufVxuIl19
