"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseTranslator = void 0;
var _basicFetcher = require("../utils/Fetcher/basicFetcher");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
// TODO: remove it and provide utils to implement translators
/**
 * Basic abstract class for translator
 */
var BaseTranslator = exports.BaseTranslator = /** @class */function () {
  function BaseTranslator(options) {
    var _this = this;
    this.options = {};
    /**
     * Util to wrap url to CORS proxy
     */
    this.wrapUrlToCorsProxy = function (url) {
      // Use as prefix
      if (typeof _this.options.corsProxy === 'string') {
        return _this.options.corsProxy + url;
      }
      // Run user defined transformation
      if (typeof _this.options.corsProxy === 'function') {
        return _this.options.corsProxy(url);
      }
      return url;
    };
    this.fetch = function (url, options) {
      return __awaiter(_this, void 0, void 0, function () {
        var fetcher;
        var _a;
        return __generator(this, function (_b) {
          fetcher = (_a = this.options.fetcher) !== null && _a !== void 0 ? _a : _basicFetcher.basicFetcher;
          return [2 /*return*/, fetcher(url, options)];
        });
      });
    };
    if (options !== undefined) {
      this.options = options;
    }
  }
  BaseTranslator.prototype.checkLimitExceeding = function (text) {
    var plainText = Array.isArray(text) ? text.join('') : text;
    var extra = plainText.length - this.getLengthLimit();
    return extra > 0 ? extra : 0;
  };
  BaseTranslator.translatorName = 'UnknownTranslator';
  BaseTranslator.isRequiredKey = function () {
    return false;
  };
  BaseTranslator.isSupportedAutoFrom = function () {
    return false;
  };
  BaseTranslator.getSupportedLanguages = function () {
    return [];
  };
  return BaseTranslator;
}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRvcnMvQmFzZVRyYW5zbGF0b3IuanMiLCJuYW1lcyI6WyJfYmFzaWNGZXRjaGVyIiwicmVxdWlyZSIsIkJhc2VUcmFuc2xhdG9yIiwiZXhwb3J0cyIsIm9wdGlvbnMiLCJfdGhpcyIsIndyYXBVcmxUb0NvcnNQcm94eSIsInVybCIsImNvcnNQcm94eSIsImZldGNoIiwiX19hd2FpdGVyIiwiZmV0Y2hlciIsIl9hIiwiYmFzaWNGZXRjaGVyIiwidW5kZWZpbmVkIiwicHJvdG90eXBlIiwiY2hlY2tMaW1pdEV4Y2VlZGluZyIsInRleHQiLCJwbGFpblRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwiZXh0cmEiLCJsZW5ndGgiLCJnZXRMZW5ndGhMaW1pdCIsInRyYW5zbGF0b3JOYW1lIiwiaXNSZXF1aXJlZEtleSIsImlzU3VwcG9ydGVkQXV0b0Zyb20iLCJnZXRTdXBwb3J0ZWRMYW5ndWFnZXMiXSwic291cmNlcyI6WyJ0cmFuc2xhdG9ycy9CYXNlVHJhbnNsYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGZXRjaGVyLCBGZXRjaGVyT3B0aW9ucywgRmV0Y2hlclJlcXVlc3RUeXBlIH0gZnJvbSAnLi4vdXRpbHMvRmV0Y2hlcic7XG5pbXBvcnQgeyBiYXNpY0ZldGNoZXIgfSBmcm9tICcuLi91dGlscy9GZXRjaGVyL2Jhc2ljRmV0Y2hlcic7XG5pbXBvcnQgeyBUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLCBsYW5nQ29kZSwgbGFuZ0NvZGVXaXRoQXV0byB9IGZyb20gJy4vVHJhbnNsYXRvcic7XG5cbmV4cG9ydCB0eXBlIFRyYW5zbGF0b3JPcHRpb25zPE8gZXh0ZW5kcyBSZWNvcmQ8YW55LCBhbnk+ID0ge30+ID0gTyAmIHtcblx0LyoqXG5cdCAqIEFQSSBlbmRwb2ludCBVUkxcblx0ICovXG5cdGFwaUhvc3Q/OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIEFjY2VzcyBrZXkgZm9yIHJlcXVlc3RzIHRvIHRyYW5zbGF0b3IgQVBJXG5cdCAqL1xuXHRhcGlLZXk/OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFVuaW9uIHRleHQgYXJyYXkgdG8gMSByZXF1ZXN0IChvciBtb3JlLCBidXQgbGVzcyB0aGFuIHVzdWFseSBhbnl3YXkpLlxuXHQgKlxuXHQgKiBPcHRpb24gZm9yIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzLCBidXQgaXQgY2FuIG1ha2UgYXJ0ZWZhY3RzIGluIHRyYW5zbGF0ZWQgdGV4dC5cblx0ICpcblx0ICogU29tZSBtb2R1bGVzIG1heSBub3Qgc3VwcG9ydCB0aGlzIGZlYXR1cmUuXG5cdCAqL1xuXHR1c2VNdWx0aXBsZXhpbmc/OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBBZGRpdGlvbmFsIGhlYWRlcnMgZm9yIHJlcXVlc3RzXG5cdCAqL1xuXHRoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuXHQvKipcblx0ICogQ3VzdG9tIGZldGNoZXJcblx0ICovXG5cdGZldGNoZXI/OiBGZXRjaGVyO1xufTtcblxuLy8gVE9ETzogcmVtb3ZlIGl0IGFuZCBwcm92aWRlIHV0aWxzIHRvIGltcGxlbWVudCB0cmFuc2xhdG9yc1xuLyoqXG4gKiBCYXNpYyBhYnN0cmFjdCBjbGFzcyBmb3IgdHJhbnNsYXRvclxuICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVHJhbnNsYXRvcjxDIGV4dGVuZHMgUmVjb3JkPGFueSwgYW55PiA9IHt9PlxuaW1wbGVtZW50cyBUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzXG57XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdHJhbnNsYXRvck5hbWU6IHN0cmluZyA9ICdVbmtub3duVHJhbnNsYXRvcic7XG5cblx0cHVibGljIHN0YXRpYyBpc1JlcXVpcmVkS2V5ID0gKCkgPT4gZmFsc2U7XG5cblx0cHVibGljIHN0YXRpYyBpc1N1cHBvcnRlZEF1dG9Gcm9tID0gKCkgPT4gZmFsc2U7XG5cblx0cHVibGljIHN0YXRpYyBnZXRTdXBwb3J0ZWRMYW5ndWFnZXMgPSAoKTogbGFuZ0NvZGVbXSA9PiBbXTtcblxuXHRwdWJsaWMgYWJzdHJhY3QgZ2V0TGVuZ3RoTGltaXQoKTogbnVtYmVyO1xuXG5cdHB1YmxpYyBhYnN0cmFjdCBnZXRSZXF1ZXN0c1RpbWVvdXQoKTogbnVtYmVyO1xuXG5cdHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zID0ge30gYXMgVHJhbnNsYXRvck9wdGlvbnM8Qz47XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBUcmFuc2xhdG9yT3B0aW9uczxDPikge1xuXHRcdGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0fVxuXHR9XG5cblx0YWJzdHJhY3QgdHJhbnNsYXRlKFxuXHRcdHRleHQ6IHN0cmluZyxcblx0XHRsYW5nRnJvbTogbGFuZ0NvZGVXaXRoQXV0byxcblx0XHRsYW5nVG86IGxhbmdDb2RlLFxuXHQpOiBQcm9taXNlPHN0cmluZz47XG5cblx0YWJzdHJhY3QgdHJhbnNsYXRlQmF0Y2goXG5cdFx0dGV4dDogc3RyaW5nW10sXG5cdFx0bGFuZ0Zyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0bGFuZ1RvOiBsYW5nQ29kZSxcblx0KTogUHJvbWlzZTxBcnJheTxzdHJpbmcgfCBudWxsPj47XG5cblx0cHVibGljIGNoZWNrTGltaXRFeGNlZWRpbmcodGV4dDogc3RyaW5nIHwgc3RyaW5nW10pIHtcblx0XHRjb25zdCBwbGFpblRleHQgPSBBcnJheS5pc0FycmF5KHRleHQpID8gdGV4dC5qb2luKCcnKSA6IHRleHQ7XG5cdFx0Y29uc3QgZXh0cmEgPSBwbGFpblRleHQubGVuZ3RoIC0gdGhpcy5nZXRMZW5ndGhMaW1pdCgpO1xuXHRcdHJldHVybiBleHRyYSA+IDAgPyBleHRyYSA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogVXRpbCB0byB3cmFwIHVybCB0byBDT1JTIHByb3h5XG5cdCAqL1xuXHRwcm90ZWN0ZWQgd3JhcFVybFRvQ29yc1Byb3h5ID0gKHVybDogc3RyaW5nKSA9PiB7XG5cdFx0Ly8gVXNlIGFzIHByZWZpeFxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvcnNQcm94eSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY29yc1Byb3h5ICsgdXJsO1xuXHRcdH1cblxuXHRcdC8vIFJ1biB1c2VyIGRlZmluZWQgdHJhbnNmb3JtYXRpb25cblx0XHRpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb3JzUHJveHkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY29yc1Byb3h5KHVybCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybDtcblx0fTtcblxuXHRwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoZXIgPSBhc3luYyA8VCBleHRlbmRzIEZldGNoZXJSZXF1ZXN0VHlwZT4oXG5cdFx0dXJsOiBzdHJpbmcsXG5cdFx0b3B0aW9uczogRmV0Y2hlck9wdGlvbnM8VD4sXG5cdCkgPT4ge1xuXHRcdGNvbnN0IGZldGNoZXIgPSB0aGlzLm9wdGlvbnMuZmV0Y2hlciA/PyBiYXNpY0ZldGNoZXI7XG5cdFx0cmV0dXJuIGZldGNoZXIodXJsLCBvcHRpb25zKTtcblx0fTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsSUFBQUEsYUFBQSxHQUFBQyxPQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTtBQUNBOzs7QUFJQSxJQUFBQyxjQUFBLEdBQUFDLE9BQUEsQ0FBQUQsY0FBQTtFQWdCQyxTQUFBQSxlQUFZRSxPQUE4QjtJQUExQyxJQUFBQyxLQUFBO0lBRG1CLEtBQUFELE9BQU8sR0FBRyxFQUEwQjtJQXlCdkQ7OztJQUdVLEtBQUFFLGtCQUFrQixHQUFHLFVBQUNDLEdBQVc7TUFDMUM7TUFDQSxJQUFJLE9BQU9GLEtBQUksQ0FBQ0QsT0FBTyxDQUFDSSxTQUFTLEtBQUssUUFBUSxFQUFFO1FBQy9DLE9BQU9ILEtBQUksQ0FBQ0QsT0FBTyxDQUFDSSxTQUFTLEdBQUdELEdBQUc7O01BR3BDO01BQ0EsSUFBSSxPQUFPRixLQUFJLENBQUNELE9BQU8sQ0FBQ0ksU0FBUyxLQUFLLFVBQVUsRUFBRTtRQUNqRCxPQUFPSCxLQUFJLENBQUNELE9BQU8sQ0FBQ0ksU0FBUyxDQUFDRCxHQUFHLENBQUM7O01BR25DLE9BQU9BLEdBQUc7SUFDWCxDQUFDO0lBRVMsS0FBQUUsS0FBSyxHQUFZLFVBQzFCRixHQUFXLEVBQ1hILE9BQTBCO01BQUEsT0FBQU0sU0FBQSxDQUFBTCxLQUFBOzs7O1VBRXBCTSxPQUFPLEdBQUcsQ0FBQUMsRUFBQSxPQUFJLENBQUNSLE9BQU8sQ0FBQ08sT0FBTyxjQUFBQyxFQUFBLGNBQUFBLEVBQUEsR0FBSUMsMEJBQVk7VUFDcEQsc0JBQU9GLE9BQU8sQ0FBQ0osR0FBRyxFQUFFSCxPQUFPLENBQUM7OztLQUM1QjtJQTlDQSxJQUFJQSxPQUFPLEtBQUtVLFNBQVMsRUFBRTtNQUMxQixJQUFJLENBQUNWLE9BQU8sR0FBR0EsT0FBTzs7RUFFeEI7RUFjT0YsY0FBQSxDQUFBYSxTQUFBLENBQUFDLG1CQUFtQixHQUExQixVQUEyQkMsSUFBdUI7SUFDakQsSUFBTUMsU0FBUyxHQUFHQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0gsSUFBSSxDQUFDLEdBQUdBLElBQUksQ0FBQ0ksSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHSixJQUFJO0lBQzVELElBQU1LLEtBQUssR0FBR0osU0FBUyxDQUFDSyxNQUFNLEdBQUcsSUFBSSxDQUFDQyxjQUFjLEVBQUU7SUFDdEQsT0FBT0YsS0FBSyxHQUFHLENBQUMsR0FBR0EsS0FBSyxHQUFHLENBQUM7RUFDN0IsQ0FBQztFQW5Dc0JwQixjQUFBLENBQUF1QixjQUFjLEdBQVcsbUJBQW1CO0VBRXJEdkIsY0FBQSxDQUFBd0IsYUFBYSxHQUFHO0lBQU0sWUFBSztFQUFMLENBQUs7RUFFM0J4QixjQUFBLENBQUF5QixtQkFBbUIsR0FBRztJQUFNLFlBQUs7RUFBTCxDQUFLO0VBRWpDekIsY0FBQSxDQUFBMEIscUJBQXFCLEdBQUc7SUFBa0IsU0FBRTtFQUFGLENBQUU7RUF1RDNELE9BQUExQixjQUFDO0NBaEVELENBZ0VDIiwiaWdub3JlTGlzdCI6W119
