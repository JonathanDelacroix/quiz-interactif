"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertHeadersToMap = exports.basicFetcher = void 0;
require("isomorphic-fetch");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var convertHeadersToMap = function (headers) {
  var map = new Map();
  headers.forEach(function (key, value) {
    map.set(key, value);
  });
  return map;
};
exports.convertHeadersToMap = convertHeadersToMap;
var basicFetcher = function (url, _a) {
  return __awaiter(void 0, void 0, void 0, function () {
    var responseType = _a.responseType,
      options = __rest(_a, ["responseType"]);
    return __generator(this, function (_b) {
      return [2 /*return*/, fetch(url, options).then(function (response) {
        return __awaiter(void 0, void 0, void 0, function () {
          var data, ok, status, statusText;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4 /*yield*/, response[responseType]()];
              case 1:
                data = _a.sent();
                ok = response.ok, status = response.status, statusText = response.statusText;
                return [2 /*return*/, {
                  headers: convertHeadersToMap(response.headers),
                  ok: ok,
                  status: status,
                  statusText: statusText,
                  data: data
                }];
            }
          });
        });
      })];
    });
  });
};
exports.basicFetcher = basicFetcher;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMvRmV0Y2hlci9iYXNpY0ZldGNoZXIuanMiLCJuYW1lcyI6WyJyZXF1aXJlIiwiY29udmVydEhlYWRlcnNUb01hcCIsImhlYWRlcnMiLCJtYXAiLCJNYXAiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJzZXQiLCJleHBvcnRzIiwiYmFzaWNGZXRjaGVyIiwidXJsIiwiX2EiLCJfX2F3YWl0ZXIiLCJyZXNwb25zZVR5cGUiLCJvcHRpb25zIiwiX19yZXN0IiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJkYXRhIiwic2VudCIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCJdLCJzb3VyY2VzIjpbInV0aWxzL0ZldGNoZXIvYmFzaWNGZXRjaGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnaXNvbW9ycGhpYy1mZXRjaCc7XG5pbXBvcnQgeyBGZXRjaGVyLCBGZXRjaGVyT3B0aW9ucywgRmV0Y2hlclJlcXVlc3RUeXBlIH0gZnJvbSAnLic7XG5cbmV4cG9ydCBjb25zdCBjb252ZXJ0SGVhZGVyc1RvTWFwID0gKGhlYWRlcnM6IEhlYWRlcnMpID0+IHtcblx0Y29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblx0aGVhZGVycy5mb3JFYWNoKChrZXksIHZhbHVlKSA9PiB7XG5cdFx0bWFwLnNldChrZXksIHZhbHVlKTtcblx0fSk7XG5cblx0cmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCBjb25zdCBiYXNpY0ZldGNoZXI6IEZldGNoZXIgPSBhc3luYyA8VCBleHRlbmRzIEZldGNoZXJSZXF1ZXN0VHlwZT4oXG5cdHVybDogc3RyaW5nLFxuXHR7IHJlc3BvbnNlVHlwZSwgLi4ub3B0aW9ucyB9OiBGZXRjaGVyT3B0aW9uczxUPixcbikgPT4ge1xuXHRyZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuXHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZVtcblx0XHRcdHJlc3BvbnNlVHlwZSBhcyBFeGNsdWRlPEZldGNoZXJSZXF1ZXN0VHlwZSwgJ3N0cmVhbSc+XG5cdFx0XSgpO1xuXG5cdFx0Y29uc3QgeyBvaywgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSByZXNwb25zZTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVhZGVyczogY29udmVydEhlYWRlcnNUb01hcChyZXNwb25zZS5oZWFkZXJzKSxcblx0XHRcdG9rLFxuXHRcdFx0c3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dCxcblx0XHRcdGRhdGEsXG5cdFx0fTtcblx0fSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQUEsT0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdPLElBQU1DLG1CQUFtQixHQUFHLFNBQUFBLENBQUNDLE9BQWdCO0VBQ25ELElBQU1DLEdBQUcsR0FBRyxJQUFJQyxHQUFHLEVBQWtCO0VBQ3JDRixPQUFPLENBQUNHLE9BQU8sQ0FBQyxVQUFDQyxHQUFHLEVBQUVDLEtBQUs7SUFDMUJKLEdBQUcsQ0FBQ0ssR0FBRyxDQUFDRixHQUFHLEVBQUVDLEtBQUssQ0FBQztFQUNwQixDQUFDLENBQUM7RUFFRixPQUFPSixHQUFHO0FBQ1gsQ0FBQztBQUFDTSxPQUFBLENBQUFSLG1CQUFBLEdBQUFBLG1CQUFBO0FBRUssSUFBTVMsWUFBWSxHQUFZLFNBQUFBLENBQ3BDQyxHQUFXLEVBQ1hDLEVBQStDO0VBQUEsT0FBQUMsU0FBQTtJQUE3QyxJQUFBQyxZQUFZLEdBQUFGLEVBQUEsQ0FBQUUsWUFBQTtNQUFLQyxPQUFPLEdBQUFDLE1BQUEsQ0FBQUosRUFBQSxFQUExQixnQkFBNEIsQ0FBRjs7TUFFMUIsc0JBQU9LLEtBQUssQ0FBQ04sR0FBRyxFQUFFSSxPQUFPLENBQUMsQ0FBQ0csSUFBSSxDQUFDLFVBQU9DLFFBQVE7UUFBQSxPQUFBTixTQUFBOzs7OztnQkFDakMscUJBQU1NLFFBQVEsQ0FDMUJMLFlBQXFELENBQ3JELEVBQUU7O2dCQUZHTSxJQUFJLEdBQUdSLEVBQUEsQ0FBQVMsSUFBQSxFQUVWO2dCQUVLQyxFQUFFLEdBQXlCSCxRQUFRLENBQUFHLEVBQWpDLEVBQUVDLE1BQU0sR0FBaUJKLFFBQVEsQ0FBQUksTUFBekIsRUFBRUMsVUFBVSxHQUFLTCxRQUFRLENBQUFLLFVBQWI7Z0JBQzlCLHNCQUFPO2tCQUNOdEIsT0FBTyxFQUFFRCxtQkFBbUIsQ0FBQ2tCLFFBQVEsQ0FBQ2pCLE9BQU8sQ0FBQztrQkFDOUNvQixFQUFFLEVBQUFBLEVBQUE7a0JBQ0ZDLE1BQU0sRUFBQUEsTUFBQTtrQkFDTkMsVUFBVSxFQUFBQSxVQUFBO2tCQUNWSixJQUFJLEVBQUFBO2lCQUNKOzs7O09BQ0QsQ0FBQzs7O0NBQ0Y7QUFBQ1gsT0FBQSxDQUFBQyxZQUFBLEdBQUFBLFlBQUEiLCJpZ25vcmVMaXN0IjpbXX0=
